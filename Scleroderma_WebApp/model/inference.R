prob_sub <- function(y, B, K, w) {
  ## Compute the probabilty a vector of observed values given basis.
  ##
  ## y : Vector of observed values
  ## B : Basis expansion.
  ## K : Covariance matrix.
  ## w : Basis weights.
  ## 
  ## returns : Single probability.
  ##
  
  yhat <- c(B %*% w)
  mvtnorm::dmvnorm(y, yhat, K)
}

gaussian_proc <- function(x,y,sigma,x_star){
  ## Compute the individualized path based on a gaussian process
  ##
  ## x: observed values
  ## y: observed marker values
  ## kfn: kernal function
  ## x_star: vector of points of interest
  
  #f <- data.frame(x=x,y=y)
  k_xx <- sigma$get_k_xx()
  k_xxs <- sigma$get_k_xxs()
  k_xsx <- sigma$get_k_xsx()
  k_xsxs <- sigma$get_k_xsxs()
  
  #print(k_xxs)
  
  f_star_bar <- t(k_xxs)%*%solve(k_xx)%*%y
  #cov_f_star <- k_xsxs - t(k_xxs)%*%solve(k_xx)%*%k_xxs
  
  #plot(x_star, f_star_bar,type = "l")
  #points(x,y)
  
  #return (c(f_star_bar,cov_f_star))
  #print(diag(cov_f_star))
  return(f_star_bar)
}

covarianceCalc <- function(x,kfn,x_star){
  thisEnv <- environment()
  k_xx <- kfn(x,x)
  k_xxs <- kfn(x,x_star)
  k_xsx <- kfn(x_star,x)
  k_xsxs <- kfn(x_star,x_star)
  cov_f_star <- k_xsxs - t(k_xxs)%*%solve(k_xx)%*%k_xxs
  
  me <- list(
    thisEnv = thisEnv,
    
    get_k_xx = function(){
      return(k_xx)
    },
    get_k_xxs = function(){
      return(k_xxs)
    },
    get_k_xsx = function(){
      return(k_xsx)
    },
    get_k_xsxs = function(){
      return(k_xsxs)
    },
    get_f_cov = function(){
      return(cov_f_star)
    }
  )
}

modelProb <- function(t,y,model){
  #number of subtypes
  G <- model$nsubtypes
  
  #number of training sets
  N <- length(t)
  
  #basis for splines
  B <- lapply(t, design, bb = model$bb)
  
  #covariance matrix
  K <- lapply(t, model$kfn)
  
  #marginal prob of subtypes
  marg <- model$marg
  
  #initialize matrix for prob
  markers <- matrix(0, G, N)
  
  #calculate probability of subtypes
  for (j in 1:G)
    markers[j, ] <- mapply(prob_sub, y, B, K, MoreArgs = list(w = model$W[, j]))
  prob_group<-model$marg*rowSums(markers)
  
  #normalize probabilites 
  norm <- prob_group/sum(prob_group)
}

modelTraj <- function(t, y, model, start, end, points){
  #number of subtypes
  G <- model$nsubtypes
  
  # basis for t
  B <- lapply(t, design, bb = model$bb)
  
  #vector of times for generation of trajectory
  X <- seq(start,end,len=points)
  
  #initalize matrix for expected trajectory for each subtype
  mat <- matrix(nrow=length(X),ncol=G)
  
  #initalize matrices for running GP over input points 
  resid <- matrix(nrow=length(t[[1]]),ncol=G)
  expect <- matrix(nrow=length(t[[1]]),ncol=G)
  
  #calculate basis for trajectory
  B_graph <- lapply(list(X), design, model$bb)
  
  #calculate expected values for subtypes
  for (j in 1:G){
    mat[,j] <- c(B_graph[[1]] %*% model$W[, j])
    expect[,j]<- c(B[[1]] %*% model$W[, j])
  }
  
  #initialize traj results matrix
  results <- matrix(nrow=length(X), ncol=G)
  
  sigma <- covarianceCalc(t[[1]],model$kfn,X)
  
  #calculate residual and traj generated by GP
  for(j in 1:G){
    resid[,j] <- y[[1]]-expect[,j]
    results[,j] <- gaussian_proc(t[[1]],resid[,j],sigma,X)
  }
  
  #add GP traj to expected traj to get results
  results <- results + mat
}

modelPlot <- function(t, y, traj, prob, start, end, points, xRange, yRange, kfn, numberLines = 9){
  names(prob) <- 1:length(prob)
  prob <- sort(prob,decreasing = TRUE)
  
  X <- seq(start,end,len=points)
  sig <- covarianceCalc(t[[1]],kfn,X) 
  
  
  plot(t[[1]], y[[1]], ylim=yRange,xlim=xRange, xlab="Time (years)", ylab="PFVC Marker", main="PFVC Predicted Trajectory")
  colors = rainbow(numberLines)
  for(j in 1:numberLines){
    subtype = as.numeric(names(prob)[j])
    lines(X, traj[,subtype], col = colors[j])
  }
  
  #plot results
  #matplot(traj, type="l")
}

gPlot <-  function(t, y, traj, prob, start, end, points, xRange, yRange, kfn, modelPoints, numberLines = 9){
  require(ggplot2)
  require(RColorBrewer)
  require(reshape2)
  
  names(prob) <- 1:length(prob)
  prob <- sort(prob,decreasing = TRUE)
  
  X <- seq(start,end,len=points)
  sig <- covarianceCalc(t[[1]][1:modelPoints],kfn,X) 
  cov <- sig$get_f_cov()
  
  var <- diag(cov)
  me <- qnorm(.975)*(var/sqrt(points))
  
  numPoints <- length(t[[1]])
  act_points <- data.frame(Time = t[[1]][1:modelPoints], PFVC = y[[1]][1:modelPoints])
  unseen_points <- data.frame(Time = t[[1]][modelPoints+1:numPoints], PFVC=y[[1]][modelPoints+1:numPoints])

  colnames(traj) <- 1:9
  
  subtypes <- names(prob)[1:numberLines]
  lab <- paste("P(", subtypes,") = ",sprintf("%1.2f",prob[1:numberLines]))
  
  df <- as.data.frame(traj[,subtypes])
  
  #hack for displaying the correct legend title
   if(numberLines == 1)
     colnames(df) <- names(prob)[1]
  
  df$X <- X
  
  traj_melted <- melt(df, id="X")
  #print(traj_melted)
  traj_melted$me <- me
  col <- brewer.pal(9, "Set1")
  
  p <- ggplot(data = traj_melted, aes(x = X, y = value, color = variable)) + 
    geom_line(size = 1) + 
    geom_point(data = act_points, aes(Time,PFVC), color="black", size = 4) +
    geom_point(data = unseen_points, aes(Time,PFVC), color="Black", shape="*", size = 8) + 
    scale_colour_manual(name = "Subtypes: ", values = col, breaks = subtypes, labels=lab) +
    scale_fill_manual(name = "Subtypes: ", values = col,breaks = subtypes, labels=lab) +
    geom_ribbon(data=traj_melted,aes(ymin=value-me, ymax=value+me, fill = variable), linetype = "blank", alpha=0.1) +
    xlab("Time (years)") + ylab("PFVC Markers") + xlim(xRange) + 
    ylim(yRange)+ ggtitle("Scleroderma Patient PFVC Predicted Trajectory") +
    theme_bw() 
  
  return(print(p))
}
  












run_infer <- function(t, y, model){
  G <- model$nsubtypes
  N <- length(t)
  B <- lapply(t, design, bb = model$bb)
  K <- lapply(t, model$kfn)
  
  marg <- model$marg
  markers <- matrix(0, G, N)
  
  for (j in 1:G)
    markers[j, ] <- mapply(prob_sub, y, B, K, MoreArgs = list(w = model$W[, j]))
  prob_group<-model$marg*rowSums(markers)
  
  norm <- prob_group/sum(prob_group)
  print(norm)
  
  X <- seq(0,15,len=50)
  mat <- matrix(nrow=length(X),ncol=G)
  resid <- matrix(nrow=length(t[[1]]),ncol=G)
  expect <- matrix(nrow=length(t[[1]]),ncol=G)
  B_graph <- lapply(list(X), design, model$bb)
  for (j in 1:G){
    mat[,j] <- c(B_graph[[1]] %*% model$W[, j])
    expect[,j]<- c(B[[1]] %*% model$W[, j])
  }
  #matplot(mat, type="l")
  
  #print(y[[1]])
  #print(expect)
  
  for(j in 1:G){
    resid[,j] <- y[[1]]-expect[,j]
  }
  
  print(resid)
  
  #gp <- gaussian_proc(t[[1]],y[[1]],model$kfn,X)
  gp3 <- gaussian_proc(t[[1]],resid[,3],model$kfn,X)
  gp2 <- gaussian_proc(t[[1]],resid[,4],model$kfn,X)
  
  results <- mat[,3] + gp3
  results2 <- mat[,4] + gp2
  
  plot(t[[1]],y[[1]], ylim=c(50,85),xlim=c(0,15), xlab="Time (years)",
       ylab="PFVC Marker")
  lines(X,results,col = "green")
  lines(X,results2, col="blue")
  lines(X,mat[,4],lty=5,col="blue")
  lines(X,mat[,3],lty=5,col="green")
  legend(0,0,c("most likely, second most likely"))
  
}